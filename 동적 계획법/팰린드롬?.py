# 팰린드롬?, 10942번, 백준

# my thoughts :
# 1. 어렵고 틀린 문제이므로 나중에 다시 풀어보아야 할 것 같습니다..!!
# 2. 개인적으로 왜 Dynamic Programming 문제인지 이해하는 것이 어려웠습니다. 하지만 왜 Dp문제인지만 이해하니 문제는 비교적 간단해보였던 것 같습니다.
# 3. 위 그림(생략하였음.)처럼 (인덱스 기준)start부터 end까지의 문자열이 팰린드롬인지를 확인하려고 할 때 문자열 [start + 1, end - 1]이 팰린드롬이라는 사실을 이미 알고 있다면 문자열 전체를 검사할 필요 없이 앞 뒤 두 글자 start와 end만 비교해보면 됩니다.
# 4. 즉, 어떤 문자열이 팰린드롬인지 확인하려면 양 끝의 문자가 같은지를 확인하고 양 끝이 같다면 양 끝단을 제외한 문자열이 팰린드롬인지 확인하면 됩니다.
# 5. 따라서, 어떤 문자열이 팰린드롬인지를 판단하는 과정은 다음과 같습니다.
# 6. 양 끝의 문자가 다르면 -->> 팰린드롬 아님.
# 7. 양 끝의 문자가 같다면 -->> 가운데 문자열을 확인해야 함.
# 8. 가운데 문자열이 팰린드롬이라면 -->> 팰린드롬 맞음.
# 9. 가운데 문자열이 팰린드롬이 아니라면 -->> 팰린드롬 아님.
# 10. 가운데 문자열이 팰린드롬인지 아닌지 모른다면 알 때까지 문자열의 길이를 앞뒤로 하나씩 줄이면서 위의 과정을 반복한다.
# 11. 가운데 문자열이 팰린드롬인지 아닌지 아는 문자열이 나올때까지 문자열의 범위를 줄여가면서 같은 과정을 반복한다는 점에서 Dp문제라고 할 수 있다.
# 12. 길이가 1인 문자열부터 길이가 n인 문자열까지 팰린드롬인지를 순차적으로 확인하면 됩니다..!!
# 13. 단, 길이가 1인 문자열과 길이가 2인 문자열이 팰린드롬인지 확인할 때는 주의가 필요합니다..!!

import sys

n = int(sys.stdin.readline().rstrip())

arr = list(map(int, sys.stdin.readline().rstrip().split()))

m = int(sys.stdin.readline().rstrip())

dp = [[0] * n for _ in range(n)]
# 참고 > dp[i][j] : i번째 인덱스부터 j번째 인덱스까지의 수가 팰린드롬인가? 

for l in range(1, n + 1, 1):
    for start in range(0, n - l + 1, 1):
        end = start + l - 1

        # 만약 문자열의 길이가 1이라면 무조건 팰린드롬입니다.
        if start == end:
            dp[start][end] = 1
        # 양 끝의 문자가 같은 경우
        elif arr[start] == arr[end]:
            # 길이가 2인 문자열이라면 무조건 팰린드롬입니다..!!
            if start + 1 == end:
                dp[start][end] = 1
            elif dp[start + 1][end - 1] == 1:
                dp[start][end] = 1
            else:
                dp[start][end] = 0
        # 양 끝의 문자가 다른 경우
        else:
            dp[start][end] = 0

for _ in range(m):
    s, e = map(int, sys.stdin.readline().rstrip().split())
    s -= 1
    e -= 1

    print(dp[s][e])
